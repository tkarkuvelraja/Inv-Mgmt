create or replace 
PACKAGE     fxgn_security IS

    g_ldap_host       VARCHAR2(100) := 'Your Organization' ;
    g_ldap_port       VARCHAR2(100) := 'Your Organization';
    g_ldap_user       VARCHAR2(100) := 'Your Organization';
    g_ldap_passwd     VARCHAR2(100) := 'Your Organization';
    g_ldap_root_base  VARCHAR2(500) := 'Your Organization';
    

    --Record Type to Hold all LDAP Attributes
    TYPE ldap_rt IS RECORD
    (
     ldap_member_cn         VARCHAR2(500)
     ,sam_account_name      fxgn_users.USER_ID%TYPE
     ,user_name             fxgn_users.USER_FULL_NAME%TYPE
     ,short_name            fxgn_users.short_name%TYPE
     ,email_id              fxgn_users.email_id%TYPE
     ,mobile_number         fxgn_users.mobile_number%TYPE
     ,title                 fxgn_users.USER_TITLE%TYPE
     ,office                fxgn_users.office%TYPE                  
     ,department            fxgn_users.department%TYPE
     ,cost_center           fxgn_users.cost_center%TYPE               
     ,hr_emp_id             fxgn_users.hr_emp_id%TYPE               
     ,loc_country           fxgn_users.loc_country%TYPE               
    );
    TYPE ldap_tab IS TABLE OF ldap_rt;   

    FUNCTION CHECK_USER_AVAILABLE(p_user_id IN VARCHAR2) RETURN BOOLEAN;
    PROCEDURE LDAP_PROCESS(x_return_status     OUT NOCOPY VARCHAR2
                           ,x_return_message   OUT NOCOPY VARCHAR2
                          );


    FUNCTION get_hash (p_user_name  IN  VARCHAR2,
                       p_password   IN  VARCHAR2)
    RETURN VARCHAR2;

    FUNCTION authenticate_user (p_user_name IN VARCHAR2,
                                p_password  IN VARCHAR2)
    RETURN boolean;

   PROCEDURE add_edit_user (p_row_id          IN  VARCHAR2,
                            p_user_full_name  IN  VARCHAR2,
                            p_email_id        IN  VARCHAR2,
                            p_short_name      IN  VARCHAR2,
                            p_mbcountry_code  IN  VARCHAR2,
                            p_mobile_number   IN  VARCHAR2,
                            p_account_locked  IN  VARCHAR2,
                            p_home_page       IN  NUMBER,
                            p_start_date      IN  DATE,
                            p_end_date        IN  DATE,
                            x_user_id         OUT VARCHAR2,
                            x_return_code     OUT VARCHAR2,
                            x_return_message  OUT VARCHAR2);

    PROCEDURE change_user_details (p_user_id         IN  VARCHAR2,
                       p_user_full_name  IN  VARCHAR2,
                       p_PASSWORD        IN  VARCHAR2,
                       p_short_name      IN  VARCHAR2,
                       p_mbcountry_code  IN  VARCHAR2,
                       p_mobile_number   IN  VARCHAR2);                       

    PROCEDURE process_login (p_user_name IN VARCHAR2,
                             p_password  IN VARCHAR2,
                             p_app_id    IN NUMBER,
                             p_session_id    IN NUMBER,
                             p_flow_page  IN NUMBER DEFAULT NULL);

    PROCEDURE change_password (p_user_name      IN  VARCHAR2,
                               p_old_password   IN  VARCHAR2,
                               p_new_password   IN  VARCHAR2); 
    
    FUNCTION open_door_authenticate_user (p_key IN VARCHAR2)
    RETURN boolean;     
    
    PROCEDURE open_door_process_login (p_key IN VARCHAR2,
                             p_app_id    IN NUMBER);
                             
    function custom_login (p_username IN VARCHAR2,
                             p_password  IN VARCHAR2) RETURN boolean;                             

   FUNCTION encrypt_string (p_input VARCHAR2) RETURN VARCHAR2;
   
   FUNCTION decrypt_string (p_input VARCHAR2) RETURN VARCHAR2;
    
   function IS_COOKIE_VALID  return BOOLEAN;
   
   function GET_USER_FROM_COOKIE  return varchar2;

END fxgn_security;

/


create or replace 
PACKAGE BODY fxgn_security
IS
  g_key RAW(32767)      := utl_raw.cast_to_raw('12345678');
  g_pad_chr VARCHAR2(1) := '~';
FUNCTION check_user_available(
    p_user_id IN VARCHAR2)
  RETURN BOOLEAN
IS
  l_return BOOLEAN;
  l_count pls_integer;
BEGIN
  SELECT COUNT(*)
  INTO l_count
  FROM fxgn_users
  WHERE upper(user_id) = upper(p_user_id);
  IF l_count           > 0 THEN
    l_return          := TRUE;
  ELSE
    l_return := FALSE;
  END IF;
  RETURN l_return;
END check_user_available;
FUNCTION get_hash(
    p_user_name IN VARCHAR2,
    p_password  IN VARCHAR2)
  RETURN VARCHAR2
AS
  l_salt VARCHAR2(30) := 'PutYourSaltHere';
BEGIN
  RETURN dbms_crypto.HASH(utl_raw.cast_to_raw(upper(p_user_name) || l_salt || upper(p_password)),dbms_crypto.hash_sh1);
END;
FUNCTION authenticate_user(
    p_user_name IN VARCHAR2,
    p_password  IN VARCHAR2)
  RETURN BOOLEAN
AS
  v_password fxgn_users.PASSWORD%TYPE;
  v_active fxgn_users.account_locked%TYPE;
  v_email fxgn_users.email_id%TYPE;
BEGIN
  BEGIN
    SELECT u.account_locked,
      u.PASSWORD,
      u.email_id
    INTO v_active,
      v_password,
      v_email
    FROM fxgn_users u
    WHERE upper(u.user_id) = upper(p_user_name)
    AND user_type          = 'E'
    AND PASSWORD           = get_hash(p_user_name, p_password);
  EXCEPTION
  WHEN no_data_found THEN
    apex_error.add_error (p_message => '<span style="color:red;">'||'Invalid username/password.'||'</span>', p_display_location => apex_error.c_inline_in_notification);
    RETURN FALSE;
  END;
  IF v_active <> 'N' THEN
    apex_error.add_error (p_message => '<span style="color:red;">'||'User locked, please contact admin.'||'</span>', p_display_location => apex_error.c_inline_in_notification );
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
PROCEDURE add_edit_user(
    p_row_id         IN VARCHAR2,
    p_user_full_name IN VARCHAR2,
    p_email_id       IN VARCHAR2,
    p_short_name     IN VARCHAR2,
    p_mbcountry_code IN VARCHAR2,
    p_mobile_number  IN VARCHAR2,
    p_account_locked IN VARCHAR2,
    p_home_page      IN NUMBER,
    p_start_date     IN DATE,
    p_end_date       IN DATE,
    x_user_id OUT VARCHAR2,
    x_return_code OUT VARCHAR2,
    x_return_message OUT VARCHAR2)
AS
BEGIN
  IF p_row_id IS NULL THEN
    BEGIN
      INSERT
      INTO fxgn_users
        (
          user_id,
          user_full_name,
          user_type,
          email_id,
          short_name,
          mobile_country_code,
          mobile_number,
          last_updated_by,
          last_updated,
          home_page,
          start_date_active
        )
        VALUES
        (
          p_email_id,
          p_user_full_name,
          'E',
          p_email_id,
          p_short_name,
          p_mbcountry_code,
          p_mobile_number,
          p_email_id,
          SYSDATE,
          p_home_page,
          p_start_date
        );
      COMMIT;
    END;
    x_return_code    := 'I';
    x_return_message := 'User has been inserted successfully!!!';
    x_user_id        := upper(p_email_id);
  elsif p_row_id     IS NOT NULL THEN
    BEGIN
      UPDATE fxgn_users
      SET user_full_name    = p_user_full_name,
        short_name          = p_short_name,
        mobile_country_code = p_mbcountry_code,
        mobile_number       = p_mobile_number,
        home_page           = p_home_page,
        account_locked      = p_account_locked,
        end_date_active     = p_end_date,
        last_updated_by     = p_email_id,
        last_updated        = SYSDATE
      WHERE ROWID           = p_row_id;
      COMMIT;
    END;
    x_return_code    := 'U';
    x_return_message := 'User has been updated successfully!!!';
  END IF;
END;
PROCEDURE change_user_details(
    p_user_id        IN VARCHAR2,
    p_user_full_name IN VARCHAR2,
    p_password       IN VARCHAR2,
    p_short_name     IN VARCHAR2,
    p_mbcountry_code IN VARCHAR2,
    p_mobile_number  IN VARCHAR2)
AS
BEGIN
  UPDATE fxgn_users
  SET user_full_name    = p_user_full_name,
    short_name          = p_short_name,
    PASSWORD            = get_hash(p_user_id, p_password),
    mobile_country_code = p_mbcountry_code,
    mobile_number       = p_mobile_number,
    reset_password      = 'N',
    last_updated_by     = p_user_id,
    last_updated        = SYSDATE
  WHERE upper(user_id)  = upper(p_user_id);
  COMMIT;
END;
PROCEDURE process_login(
    p_user_name  IN VARCHAR2,
    p_password   IN VARCHAR2,
    p_app_id     IN NUMBER,
    p_session_id IN NUMBER,
    p_flow_page  IN NUMBER DEFAULT NULL)
AS
  v_result          BOOLEAN       := FALSE;
  v_collection_name VARCHAR2(100) := 'CUSTOM_AUTHENTICATION';
BEGIN
  v_result   := authenticate_user(p_user_name, p_password);
  IF v_result = TRUE THEN
    UPDATE fxgn_users
    SET last_logged      = LOCALTIMESTAMP
    WHERE upper(user_id) = upper(p_user_name);
    -- Redirect to Page 1 (Home Page).
    wwv_flow_custom_auth_std.post_login(p_user_name, -- p_User_Name
    p_password,                                      -- p_Password
    p_session_id, p_app_id || ':'||NVL(p_flow_page,1)                   -- p_Flow_page
    );
    -- owa_util.redirect_url('f?p=:1:');
  ELSE
    -- Login Failure, redirect to page 101 (Login Page).
    owa_util.redirect_url('f?p=:101:');
  END IF;
END;
PROCEDURE change_password(
    p_user_name    IN VARCHAR2,
    p_old_password IN VARCHAR2,
    p_new_password IN VARCHAR2)
AS
  v_rowid ROWID;
BEGIN
  SELECT ROWID
  INTO v_rowid
  FROM fxgn_users
  WHERE upper(user_id) = upper(p_user_name)
  AND PASSWORD         = get_hash(p_user_name, p_old_password) FOR UPDATE;
  UPDATE fxgn_users
  SET PASSWORD = get_hash(p_user_name, p_new_password)
  WHERE ROWID  = v_rowid;
  COMMIT;
EXCEPTION
WHEN no_data_found THEN
  apex_error.add_error (p_message => '<span style="color:red;">'||'Invalid username/password.'||'</span>', p_display_location => apex_error.c_inline_in_notification);
END;
FUNCTION open_door_authenticate_user(
    p_key IN VARCHAR2)
  RETURN BOOLEAN
AS
  v_key VARCHAR2(100);
BEGIN
  BEGIN
    SELECT fbpa.PASSWORD
    INTO v_key
    FROM fxgn_rest_users fbpa
    WHERE upper(fbpa.PASSWORD) = upper(p_key);
  EXCEPTION
  WHEN no_data_found THEN
    apex_error.add_error (p_message => '<span style="color:red;">'||'Invalid Key.'||'</span>', p_display_location => apex_error.c_inline_in_notification);
    RETURN FALSE;
  END;
  IF v_key IS NULL THEN
    apex_error.add_error (p_message => '<span style="color:red;">'||'Invalid Key.'||'</span>', p_display_location => apex_error.c_inline_in_notification );
    RETURN FALSE;
  END IF;
  RETURN TRUE;
END;
PROCEDURE open_door_process_login(
    p_key    IN VARCHAR2,
    p_app_id IN NUMBER)
AS
  v_result BOOLEAN := FALSE;
  v_key    VARCHAR2(100);
BEGIN
  v_result   := open_door_authenticate_user (p_key);
  IF v_result = TRUE THEN
    -- Redirect to Page 1 (Home Page).
    SELECT fbpa.PASSWORD
    INTO v_key
    FROM fxgn_rest_users fbpa
    WHERE upper(fbpa.PASSWORD) = upper(p_key);
    wwv_flow_custom_auth_std.post_login(v_key, -- p_User_Name
    NULL,                                      -- p_Password
    v('APP_SESSION'),                          -- p_Session_Id
    p_app_id || ':6'                           -- p_Flow_page
    );
  ELSE
    -- Login Failure, redirect to page 101 (Login Page).
    owa_util.redirect_url('f?p='||p_app_id||':1:'||v('APP_SESSION'));
  END IF;
END;
PROCEDURE ldap_process(
    x_return_status OUT nocopy  VARCHAR2 ,
    x_return_message OUT nocopy VARCHAR2 )
IS
  retval pls_integer;
  my_session dbms_ldap.SESSION;
  my_attrs dbms_ldap.string_collection;
  my_message dbms_ldap.message;
  my_entry dbms_ldap.message;
  entry_index pls_integer;
  my_dn        VARCHAR2(256);
  my_attr_name VARCHAR2(256);
  my_ber_elmt dbms_ldap.ber_element;
  attr_index pls_integer;
  i pls_integer;
  my_vals dbms_ldap.string_collection ;
  l_range_from pls_integer := 0;
  l_range_to pls_integer;
  l_proceed VARCHAR2(1)                    := 'Y';
  l_count pls_integer                      := 0;
  l_record_index pls_integer               := 0;
  l_ldap_tab fxgn_security.ldap_tab        := ldap_tab();
  l_ldap_insert_tab fxgn_security.ldap_tab := ldap_tab();
  l_ldap_update_tab fxgn_security.ldap_tab := ldap_tab();
  l_available BOOLEAN;
  l_insert_count pls_integer := 0;
  l_update_count pls_integer := 0;
BEGIN
  x_return_status  := 'S';
  x_return_message := 'Process Inititaed...';
  fxgn_debug_pkg.init('FXGN_SECURITY');
  fxgn_debug_pkg.set_context ( p_procedure => 'LDAP_PROCESS', p_event => 'SYNC WITH LDAP', p_pk_name => 'TODAY', p_pk_value => TO_CHAR(SYSDATE,'DDMONYYYY') );
  retval                    := -1;
  dbms_ldap.use_exception   := TRUE;
  dbms_ldap.utf8_conversion := FALSE; --UTF conversion of the LAST_VALUE
  BEGIN
    fxgn_debug_pkg.ADD('[LP]Connection Initiated with LDAP Server...');
    my_session := dbms_ldap.init(hostname => g_ldap_host,portnum =>g_ldap_port);
  EXCEPTION
  WHEN OTHERS THEN
    fxgn_debug_pkg.ADD('[LP]Connection Error :['||sqlerrm||']');
    x_return_status  := 'E';
    x_return_message := 'Could not Established Connection ['||sqlerrm||']';
    l_proceed        := 'N';
  END;
  IF (l_proceed = 'Y') THEN --Authenticate
    BEGIN
      retval := dbms_ldap.simple_bind_s (ld => my_session ,dn => g_ldap_user ,passwd => g_ldap_passwd );
      fxgn_debug_pkg.ADD('[LP]Session Established...');
    EXCEPTION
    WHEN OTHERS THEN
      fxgn_debug_pkg.ADD('[LP]Authentication Error ['||sqlerrm||']');
      x_return_status  := 'E';
      x_return_message := 'Authentication Error :'||g_ldap_user||'['||sqlerrm||']';
      l_proceed        := 'N';
    END;
  END IF;                   --Authenticate
  IF (l_proceed = 'Y') THEN --Good to Process
    --Lets Start the proces to get Details ...
    l_range_from    := 0;
    l_range_to      := 1499;
    WHILE (l_proceed = 'Y' )
    LOOP --START
      l_count     := l_count+1;
      my_attrs(0) := 'member;range='||l_range_from||'-'||l_range_to; --range=0-1499';
      fxgn_debug_pkg.ADD('[LP]Range = '||my_attrs(0)||' Iteration = '||l_count);
      BEGIN -- for damac employees
        retval := dbms_ldap.search_s ( ld => my_session, base => g_ldap_root_base, SCOPE => dbms_ldap.scope_subtree, FILTER => '(!(userAccountControl:1.2.840.113556.1.4.803:=2))', attrs => my_attrs, attronly => 0, res => my_message );
        --FXGN_DEBUG_PKG.ADD('[LP]retval = '||retval);
        retval := dbms_ldap.count_entries(my_session, my_message);
        --FXGN_DEBUG_PKG.ADD('[LP]Count = '||retval);
        -- get the first entry
        my_entry       := dbms_ldap.first_entry(my_session, my_message);
        entry_index    := 1;
        WHILE my_entry IS NOT NULL
        LOOP
          -- print the current entry
          my_dn              := dbms_ldap.get_dn(my_session, my_entry);
          my_attr_name       := dbms_ldap.first_attribute(my_session,my_entry,my_ber_elmt);
          attr_index         := 1;
          WHILE my_attr_name IS NOT NULL
          LOOP
            my_vals         := dbms_ldap.get_values (my_session, my_entry,my_attr_name);
            IF my_vals.count > 0 THEN
              FOR i IN my_vals.FIRST..my_vals.LAST
              LOOP
                --FXGN_DEBUG_PKG.ADD('[LP] Processing : '||MY_VALS(I));
                IF my_attr_name LIKE('%member%') THEN
                  l_record_index := l_record_index + 1;
                  l_ldap_tab.EXTEND;
                  --FXGN_DEBUG_PKG.ADD('Inserting [index,i,Value]=['||l_record_index||','||i||','||MY_VALS(I)||']');
                  l_ldap_tab(l_record_index).ldap_member_cn := my_vals(i);
                END IF;
              END LOOP;
            END IF;
            my_attr_name := dbms_ldap.next_attribute(my_session,my_entry, my_ber_elmt);
            attr_index   := attr_index+1;
          END LOOP;
          my_entry    := dbms_ldap.next_entry(my_session, my_entry);
          entry_index := entry_index+1;
        END LOOP;
        l_range_from := l_range_from+1500;
        l_range_to   := l_range_to  + 1500;
      EXCEPTION
      WHEN OTHERS THEN
        fxgn_debug_pkg.ADD('[LP]Nothing Retrieved in Iteration='||l_count||'['||sqlerrm||']');
        l_proceed := 'N';
      END;
      BEGIN -- for non damac employees
        retval := dbms_ldap.search_s ( ld => my_session, base => 'CN=Non-DAMAC Users,OU=Internal,OU=Generic Email DL,OU=DamacHolding-Exchange-DL,DC=damacholding,DC=home', SCOPE => dbms_ldap.scope_subtree, FILTER => '(!(userAccountControl:1.2.840.113556.1.4.803:=2))', attrs => my_attrs, attronly => 0, res => my_message );
        --FXGN_DEBUG_PKG.ADD('[LP]retval = '||retval);
        retval := dbms_ldap.count_entries(my_session, my_message);
        --FXGN_DEBUG_PKG.ADD('[LP]Count = '||retval);
        -- get the first entry
        my_entry       := dbms_ldap.first_entry(my_session, my_message);
        entry_index    := 1;
        WHILE my_entry IS NOT NULL
        LOOP
          -- print the current entry
          my_dn              := dbms_ldap.get_dn(my_session, my_entry);
          my_attr_name       := dbms_ldap.first_attribute(my_session,my_entry,my_ber_elmt);
          attr_index         := 1;
          WHILE my_attr_name IS NOT NULL
          LOOP
            my_vals         := dbms_ldap.get_values (my_session, my_entry,my_attr_name);
            IF my_vals.count > 0 THEN
              FOR i IN my_vals.FIRST..my_vals.LAST
              LOOP
                --FXGN_DEBUG_PKG.ADD('[LP] Processing : '||MY_VALS(I));
                IF my_attr_name LIKE('%member%') THEN
                  l_record_index := l_record_index + 1;
                  l_ldap_tab.EXTEND;
                  --FXGN_DEBUG_PKG.ADD('Inserting [index,i,Value]=['||l_record_index||','||i||','||MY_VALS(I)||']');
                  l_ldap_tab(l_record_index).ldap_member_cn := my_vals(i);
                END IF;
              END LOOP;
            END IF;
            my_attr_name := dbms_ldap.next_attribute(my_session,my_entry, my_ber_elmt);
            attr_index   := attr_index+1;
          END LOOP;
          my_entry    := dbms_ldap.next_entry(my_session, my_entry);
          entry_index := entry_index+1;
        END LOOP;
      EXCEPTION
      WHEN OTHERS THEN
        fxgn_debug_pkg.ADD('[LP]Nothing Retrieved in Iteration='||l_count||'['||sqlerrm||']');
        l_proceed := 'N';
      END;
    END LOOP; --START
  END IF;     --Good to Process
  --
  --Total Records Fetched from LDAP
  --FOR i in l_ldap_tab.FIRST .. l_ldap_tab.LAST LOOP
  --   FXGN_DEBUG_PKG.ADD(l_ldap_tab(i).ldap_member_cn);
  --END LOOP;
  IF (l_ldap_tab.count = 0) THEN --Get LDAP Attributes
    x_return_status   := 'E';
    x_return_message  := 'No Lines Retrieved from AD';
  ELSE
    --FXGN_DEBUG_PKG.ADD('[LP]Total CNs To Process = '||l_ldap_tab.count);
    FOR indx IN l_ldap_tab.FIRST .. l_ldap_tab.LAST
    LOOP --ITERATE
      --FXGN_DEBUG_PKG.ADD('[CN='||l_ldap_tab(indx).ldap_member_cn||']');
      my_attrs(0) :='*';
      retval      := dbms_ldap.search_s ( ld => my_session, base => l_ldap_tab(indx).ldap_member_cn, SCOPE => dbms_ldap.scope_subtree, FILTER => '(&(OBJECTCLASS=USER) )', attrs => my_attrs, attronly => 0, res => my_message);
      --dbms_output.put_line ('RETVAL = '||RETVAL);
      -- count the number of entries returned
      retval := dbms_ldap.count_entries(my_session, my_message);
      --dbms_output.put_line ('RETVAL = '||RETVAL);
      -- get the first entry
      my_entry    := dbms_ldap.first_entry(my_session, my_message);
      entry_index := 1;
      -- Loop through each of the entries one by one
      WHILE my_entry IS NOT NULL
      LOOP --ITERATE-1
        -- print the current entry
        my_dn := dbms_ldap.get_dn(my_session, my_entry);
        --dbms_output.put_line ('my_dn = '||my_dn);
        my_attr_name       := dbms_ldap.first_attribute(my_session,my_entry,my_ber_elmt);
        attr_index         := 1;
        WHILE my_attr_name IS NOT NULL
        LOOP --ATTR_NAME
          --dbms_output.put_line ('MY_ATTR_NAME = '||MY_ATTR_NAME);
          my_vals         := dbms_ldap.nls_convert_to_utf8(dbms_ldap.get_values(my_session, my_entry,my_attr_name));
          IF my_vals.count > 0 THEN --process values
            FOR i IN my_vals.FIRST..my_vals.LAST
            LOOP --MyVals Loop
              --DBMS_OUTPUT.PUT_LINE('SRATH MY_ATTR_NAME : '||MY_ATTR_NAME||'='||SUBSTR(MY_VALS(I),1,500));
              IF my_attr_name IN('sAMAccountName')THEN
                l_ldap_tab(indx).sam_account_name := upper(my_vals(i)); -- user_id
                --DBMS_OUTPUT.PUT_LINE('sAMAccountName='||SUBSTR(MY_VALS(I),1,100));
              elsif my_attr_name IN('name')THEN
                --DBMS_OUTPUT.PUT_LINE('name='||MY_VALS(I));
                l_ldap_tab(indx).user_name := SUBSTR(my_vals(i),1,500); --User Name
              elsif my_attr_name IN('sn')THEN
                --DBMS_OUTPUT.PUT_LINE('sn='||MY_VALS(I));
                l_ldap_tab(indx).short_name :=upper(SUBSTR(my_vals(i),1,20)); -- Short Name
              elsif my_attr_name IN('mail')THEN
                --DBMS_OUTPUT.PUT_LINE('mail='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).email_id := my_vals(i); -- mail_id
                --null;
              elsif my_attr_name IN('mobile')THEN
                --DBMS_OUTPUT.PUT_LINE('mobile='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).mobile_number :=my_vals(i); --mobile
                --null;
              elsif my_attr_name IN('title')THEN
                --DBMS_OUTPUT.PUT_LINE('title='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).title:= my_vals(i); --title
                --null;
              elsif my_attr_name IN('physicalDeliveryOfficeName')THEN
                --DBMS_OUTPUT.PUT_LINE('physicalDeliveryOfficeName='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).office := my_vals(i); --Office
                --null;
              elsif my_attr_name IN('department')THEN
                --DBMS_OUTPUT.PUT_LINE('department='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).department :=my_vals(i); --Department
                --null;
              elsif my_attr_name IN('extensionAttribute14')THEN
                --DBMS_OUTPUT.PUT_LINE('extensionAttribute14='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).cost_center :=my_vals(i); -- cost_centre
                --null;
              elsif my_attr_name IN('employeeID')THEN
                --DBMS_OUTPUT.PUT_LINE('employeeID='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).hr_emp_id :=my_vals(i); -- Emp HR ID
                --null;
              elsif my_attr_name IN('co')THEN
                --DBMS_OUTPUT.PUT_LINE('co='||SUBSTR(MY_VALS(I),1,100));
                l_ldap_tab(indx).loc_country := my_vals(i); -- Country
                --null;
              END IF;
            END LOOP; --MyVals Loop
          END IF;     --process values
          my_attr_name := dbms_ldap.next_attribute(my_session,my_entry, my_ber_elmt);
          attr_index   := attr_index+1;
        END LOOP; --ATTR_NAME
        --DBMS_OUTPUT.PUT_LINE( 'USER_NAME' || ' :' || USER_NAME ||' mail :'||MAIL_ID||' U_name '||U_name||' title '||TITLE||' PHYSICALDELIVERYOFFICENAME '||PHYSICALDELIVERYOFFICENAME
        --        ||' extensionAttribute14 '||extensionAttribute14);
        my_entry    := dbms_ldap.next_entry(my_session, my_entry);
        entry_index := entry_index+1;
      END LOOP; --ITERATE-1
    END LOOP;   --ITERATE
  END IF;       --Get LDAP Attributes
  --DELETE FROM FXGN_USERS_STAGE_LDAP;
  --COMMIT;
  FOR indx IN 1 .. l_ldap_tab.count
  LOOP --l_ldap_tab.FIRST .. l_ldap_tab.LAST LOOP
    l_available := fxgn_security.check_user_available(p_user_id => l_ldap_tab(indx).sam_account_name);
    --DBMS_OUTPUT.PUT_LINE('indx = '||indx||','||l_ldap_tab(indx).sam_account_name);
    IF (l_available) THEN
      l_ldap_update_tab.EXTEND;
      l_update_count := l_update_count + 1;
      --DBMS_OUTPUT.PUT_LINE('UPDATE Count = '||l_ldap_update_tab.count);
      fxgn_debug_pkg.ADD('User Id['||l_update_count||'] = '||l_ldap_tab(indx).sam_account_name||' to Be Updated');
      l_ldap_update_tab(l_update_count) := l_ldap_tab(indx);
    ELSE
      l_ldap_insert_tab.EXTEND;
      l_insert_count := l_insert_count + 1;
      fxgn_debug_pkg.ADD('User Id['||l_insert_count||'] = '||l_ldap_tab(indx).sam_account_name||' to Be Added');
      l_ldap_insert_tab(l_insert_count) := l_ldap_tab(indx);
    END IF;
  END LOOP;
  fxgn_debug_pkg.ADD('[LP]Total Lines to Update = '||l_ldap_update_tab.count);
  fxgn_debug_pkg.ADD('[LP]Total Lines to Insert = '||l_ldap_insert_tab.count);
  --Update the Users Table LDAP_SYNC to N to Reset
  UPDATE fxgn_users
  SET ldap_sync = 'N' ;
  COMMIT;
  --We will First Insert and then Update from the respective collections
  forall indx IN 1 .. l_ldap_insert_tab.count
  INSERT
  INTO fxgn_users
    (
      user_id ,
      user_full_name ,
      short_name ,
      email_id ,
      mobile_number ,
      user_title ,
      office ,
      department ,
      cost_center ,
      hr_emp_id ,
      loc_country ,
      start_date_active ,
      ldap_sync ,
      ldap_sync_date
    )
    VALUES
    (
      l_ldap_insert_tab(indx).sam_account_name ,
      l_ldap_insert_tab(indx).user_name ,
      l_ldap_insert_tab(indx).short_name ,
      'xxxx'||l_ldap_insert_tab(indx).email_id ,
      l_ldap_insert_tab(indx).mobile_number ,
      l_ldap_insert_tab(indx).title ,
      l_ldap_insert_tab(indx).office ,
      l_ldap_insert_tab(indx).department ,
      l_ldap_insert_tab(indx).cost_center ,
      l_ldap_insert_tab(indx).hr_emp_id ,
      l_ldap_insert_tab(indx).loc_country ,
      LOCALTIMESTAMP ,
      'Y' ,
      LOCALTIMESTAMP
    );
  --Lets update all the entries in the FXGN_USERS Table
  forall indx IN 1 .. l_ldap_update_tab.count
  UPDATE fxgn_users
  SET user_full_name      = l_ldap_update_tab(indx).user_name ,
    short_name            = l_ldap_update_tab(indx).short_name ,
    user_type             = 'I' ,
    email_id              = 'xxxx'||l_ldap_update_tab(indx).email_id ,
    mobile_number         = l_ldap_update_tab(indx).mobile_number ,
    user_title            = l_ldap_update_tab(indx).title ,
    office                = l_ldap_update_tab(indx).office ,
    department            = l_ldap_update_tab(indx).department ,
    cost_center           = l_ldap_update_tab(indx).cost_center ,
    hr_emp_id             = l_ldap_update_tab(indx).hr_emp_id ,
    loc_country           = l_ldap_update_tab(indx).loc_country ,
    ldap_sync             = 'Y' ,
    ldap_sync_date        = LOCALTIMESTAMP
  WHERE user_id           = l_ldap_update_tab(indx).sam_account_name
  AND upper(user_id) NOT IN('MAGDY.ELHUSSINY','MAGDY.ELHUSSEINY') ;
  --Finally Lets update the lines which are not synced with LDAP to inactive
  UPDATE fxgn_users
  SET end_date_active     = LOCALTIMESTAMP ,
    account_locked        = 'Y' ,
    ldap_sync_date        = LOCALTIMESTAMP
  WHERE ldap_sync         = 'N'
  AND user_type           = 'I'
  AND end_date_active    IS NULL
  AND upper(user_id) NOT IN('MAGDY.ELHUSSINY','MAGDY.ELHUSSEINY') ;
    
  UPDATE fxgn_users
     SET EMAIL_ID     = 'xxxxxamira1@damacgroup.com'
   WHERE upper(user_id) = 'AMIRA' ;
  COMMIT;
  
  retval           := dbms_ldap.unbind_s(my_session);
  x_return_status  := 'S';
  x_return_message := 'Process Completed...';
  --my_attrs(0) := 'member;range=0-1499';
EXCEPTION
WHEN OTHERS THEN
  x_return_status  := 'E';
  x_return_message := sqlerrm;
  retval           := dbms_ldap.unbind_s(my_session);
END ldap_process;
FUNCTION custom_login(
    p_username IN VARCHAR2,
    p_password IN VARCHAR2)
  RETURN BOOLEAN
AS
  v_result BOOLEAN := FALSE;
BEGIN
  v_result := authenticate_user(p_username, p_password);
  RETURN v_result;
END;
FUNCTION encrypt_string(
    p_input VARCHAR2)
  RETURN VARCHAR2
AS
  l_encrypted_raw RAW (2000);
  l_key RAW (320);
  l_encryption_type pls_integer :=dbms_crypto.des_cbc_pkcs5;
  l_iv RAW (320);
BEGIN
  SELECT PASSWORD
  INTO l_key
  FROM fxgn_rest_users
  WHERE user_id = 'KEY_BYTES_RAW';
  SELECT PASSWORD INTO l_iv FROM fxgn_rest_users WHERE user_id = 'IV_RAW';
  l_encrypted_raw := dbms_crypto.encrypt (src => utl_i18n.string_to_raw (p_input, 'AL32UTF8'), typ => l_encryption_type, KEY => l_key, iv => l_iv);
  RETURN utl_raw.cast_to_varchar2 (utl_encode.base64_encode (l_encrypted_raw));
END encrypt_string;
FUNCTION decrypt_string(
    p_input VARCHAR2)
  RETURN VARCHAR2
AS
  l_decrypted_raw RAW (2000);
  l_key RAW (320);
  l_encryption_type pls_integer :=dbms_crypto.des_cbc_pkcs5;
  l_iv RAW (320);
BEGIN
  SELECT PASSWORD
  INTO l_key
  FROM fxgn_rest_users
  WHERE user_id = 'KEY_BYTES_RAW';
  SELECT PASSWORD INTO l_iv FROM fxgn_rest_users WHERE user_id = 'IV_RAW';
  l_decrypted_raw := dbms_crypto.decrypt (src => utl_encode.base64_decode (utl_raw.cast_to_raw (p_input)), typ => l_encryption_type, KEY => l_key, iv => l_iv);
  RETURN utl_i18n.raw_to_char (l_decrypted_raw, 'AL32UTF8');
END decrypt_string;
FUNCTION IS_COOKIE_VALID
  RETURN BOOLEAN
IS
BEGIN
  IF GET_USER_FROM_COOKIE IS NOT NULL THEN
    RETURN true;
  END IF;
  RETURN false;
EXCEPTION
WHEN OTHERS THEN
  RETURN false;
END IS_COOKIE_VALID;
FUNCTION GET_USER_FROM_COOKIE
  RETURN VARCHAR2
IS
  L_USER FXGN_USERS.USER_ID%type;
  L_USER_TYPE FXGN_USERS.USER_TYPE%type;
  V_COOKIE_USER VARCHAR2(255);
  V_COOKIE      VARCHAR2(255);
BEGIN
  BEGIN
    SELECT cookie_name INTO V_COOKIE FROM FXGN_COOKIES WHERE app_id = NV('APP_ID') AND NVL(ENABLED,'Y') = 'Y';
  EXCEPTION
  WHEN no_data_found THEN
    V_COOKIE := NULL;
  END;
  V_COOKIE_USER := APEX_AUTHENTICATION.GET_LOGIN_USERNAME_COOKIE(p_cookie_name => V_COOKIE);
  BEGIN
    SELECT DISTINCT USER_TYPE,
      USER_ID
    INTO L_USER_TYPE,
      L_USER
    FROM FXGN_USER_MATRIX_V
    WHERE LOWER(USER_ID) = fxgn_security.decrypt_string(V_COOKIE_USER)
    AND password        IS NOT NULL;
  EXCEPTION
  WHEN OTHERS THEN
    L_USER_TYPE := 'F'; -- Failed
  END;
  IF L_USER_TYPE IN ('I') THEN
    RETURN L_USER;
  END IF;
EXCEPTION
WHEN OTHERS THEN
  RETURN NULL;
END GET_USER_FROM_COOKIE;

END fxgn_security;
/
